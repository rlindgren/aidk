/**
 * Streaming Types
 *
 * Platform-independent types for streaming model responses and engine events.
 * Used by both backend (aidk-core) and frontend (aidk-client).
 *
 * ## Event Architecture
 *
 * - **StreamEvent**: Model output events (content, reasoning, messages, tool calls)
 * - **EngineEvent**: Orchestration events (execution lifecycle, ticks, tool results)
 * - **EngineStreamEvent**: Combined union of both (what engine.stream() yields)
 *
 * ## Event Pattern
 *
 * For streamable content, events follow the pattern:
 * ```
 * [thing]_start → [thing]_delta (0..n) → [thing]_end → [thing] (fully formed)
 * ```
 *
 * This allows consumers to choose granularity:
 * - Streaming UI: Listen for `*_delta` events
 * - Simple consumption: Listen for `content`, `reasoning`, `message`, `tool_call`
 */

import type { ContentBlock } from "./blocks";
import type { BlockType } from "./block-types";
import type { Message } from "./messages";
import type { TokenUsage } from "./models";
import type { ToolExecutor } from "./tools";

// ============================================================================
// Stop Reason
// ============================================================================

/**
 * Stop reason enumeration.
 * Defines why model generation stopped.
 *
 * Key distinction:
 * - NATURAL_COMPLETION: Model decided to stop (maps to provider's end_turn, stop, etc.)
 * - EXPLICIT_COMPLETION: Engine/runtime requested the stop (max ticks, abort, etc.)
 *
 * Usage by layer:
 * - StreamEvent (message_end): Model's stop reason (TOOL_USE, MAX_TOKENS, NATURAL_COMPLETION)
 * - EngineEvent (execution): May be EXPLICIT_COMPLETION if engine stopped early
 */
export enum StopReason {
  MAX_TOKENS = "max_tokens",
  STOP_SEQUENCE = "stop_sequence",
  CONTENT_FILTER = "content_filter",
  TOOL_USE = "tool_use",
  FUNCTION_CALL = "function_call",
  UNSPECIFIED = "unspecified",
  OTHER = "other",
  STOP = "stop",
  PAUSED = "paused",
  FORMAT_ERROR = "format_error",
  EMPTY_RESPONSE = "empty_response",
  NO_CONTENT = "no_content",
  EXPLICIT_COMPLETION = "explicit_completion",
  NATURAL_COMPLETION = "natural_completion",
  ERROR = "error",
}

// ============================================================================
// Base Event Structure
// ============================================================================

/**
 * Base fields shared by all stream events.
 */
export interface StreamEventBase {
  /** Normalized event ID (generated by entity-ids if provider doesn't provide one) */
  id: string;

  /** Tick number (default 1 for direct model calls without engine) */
  tick: number;

  /** ISO 8601 timestamp when event was created/emitted */
  timestamp: string;

  /** Original provider event/chunk for pass-through (debugging, provider-specific features) */
  raw?: unknown;
}

// ============================================================================
// StreamEvent (Model Output)
// ============================================================================

/**
 * Content block events (text, images, etc.)
 */
export type ContentStartEvent = {
  type: "content_start";
  blockType: BlockType;
  blockIndex: number;
} & StreamEventBase;

export type ContentDeltaEvent = {
  type: "content_delta";
  blockType: BlockType;
  blockIndex: number;
  delta: string;
} & StreamEventBase;

export type ContentEndEvent = {
  type: "content_end";
  blockType: BlockType;
  blockIndex: number;
} & StreamEventBase;

export type ContentEvent = {
  type: "content";
  blockIndex: number;
  content: ContentBlock;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Reasoning/thinking events (separate for easy filtering)
 */
export type ReasoningStartEvent = {
  type: "reasoning_start";
  blockIndex: number;
} & StreamEventBase;

export type ReasoningDeltaEvent = {
  type: "reasoning_delta";
  blockIndex: number;
  delta: string;
} & StreamEventBase;

export type ReasoningEndEvent = {
  type: "reasoning_end";
  blockIndex: number;
} & StreamEventBase;

export type ReasoningEvent = {
  type: "reasoning";
  blockIndex: number;
  reasoning: string;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Message lifecycle events
 */
export type MessageStartEvent = {
  type: "message_start";
  role: "assistant";
  model?: string;
} & StreamEventBase;

export type MessageEndEvent = {
  type: "message_end";
  stopReason: StopReason;
  usage?: TokenUsage;
} & StreamEventBase;

export type MessageEvent = {
  type: "message";
  message: Message;
  stopReason: StopReason;
  usage?: TokenUsage;
  model?: string;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Tool call events (model requesting tool execution)
 */
export type ToolCallStartEvent = {
  type: "tool_call_start";
  callId: string;
  name: string;
  blockIndex: number;
} & StreamEventBase;

export type ToolCallDeltaEvent = {
  type: "tool_call_delta";
  callId: string;
  blockIndex: number;
  delta: string;
} & StreamEventBase;

export type ToolCallEndEvent = {
  type: "tool_call_end";
  callId: string;
  blockIndex: number;
} & StreamEventBase;

export type ToolCallEvent = {
  type: "tool_call";
  callId: string;
  blockIndex: number;
  name: string;
  input: Record<string, unknown>;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Error event
 */
export type StreamErrorEvent = {
  type: "error";
  error: {
    message: string;
    code?: string;
  };
} & StreamEventBase;

/**
 * StreamEvent - All model output events.
 *
 * Discriminated union of all events that come from model streaming.
 */
export type StreamEvent =
  // Content blocks
  | ContentStartEvent
  | ContentDeltaEvent
  | ContentEndEvent
  | ContentEvent
  // Reasoning/thinking
  | ReasoningStartEvent
  | ReasoningDeltaEvent
  | ReasoningEndEvent
  | ReasoningEvent
  // Message lifecycle
  | MessageStartEvent
  | MessageEndEvent
  | MessageEvent
  // Tool calls
  | ToolCallStartEvent
  | ToolCallDeltaEvent
  | ToolCallEndEvent
  | ToolCallEvent
  // Errors
  | StreamErrorEvent;

// ============================================================================
// EngineEvent (Orchestration)
// ============================================================================

/**
 * Execution lifecycle events
 */
export type ExecutionStartEvent = {
  type: "execution_start";
  executionId: string;
  threadId: string;
  parentExecutionId?: string;
  rootExecutionId?: string;
  componentName?: string;
  sessionId?: string;
} & StreamEventBase;

export type ExecutionEndEvent = {
  type: "execution_end";
  executionId: string;
  threadId: string;
  parentExecutionId?: string;
  rootExecutionId?: string;
  output: unknown;
  sessionId?: string;
} & StreamEventBase;

export type ExecutionEvent = {
  type: "execution";
  executionId: string;
  threadId: string;
  parentExecutionId?: string;
  rootExecutionId?: string;
  output: unknown;
  usage: TokenUsage;
  stopReason: StopReason;
  ticks: number;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Tick lifecycle events
 */
export type TickStartEvent = {
  type: "tick_start";
  tick: number;
} & StreamEventBase;

export type TickEndEvent = {
  type: "tick_end";
  tick: number;
  usage?: TokenUsage;
} & StreamEventBase;

export type TickEvent = {
  type: "tick";
  tick: number;
  usage: TokenUsage;
  stopReason: StopReason;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Tool result event (unified - executedBy indicates source)
 */
export type ToolResultEvent = {
  type: "tool_result";
  callId: string;
  name: string;
  result: unknown;
  isError?: boolean;
  executedBy: ToolExecutor;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Tool confirmation events (for requiresConfirmation tools)
 */
export type ToolConfirmationRequiredEvent = {
  type: "tool_confirmation_required";
  callId: string;
  name: string;
  input: Record<string, unknown>;
  message: string;
} & StreamEventBase;

export type ToolConfirmationResultEvent = {
  type: "tool_confirmation_result";
  callId: string;
  confirmed: boolean;
  always?: boolean;
} & StreamEventBase;

/**
 * Engine error event
 */
export type EngineErrorEvent = {
  type: "engine_error";
  error: {
    message: string;
    code?: string;
  };
} & StreamEventBase;

/**
 * EngineEvent - All orchestration events.
 *
 * Discriminated union of all events from engine orchestration.
 */
export type EngineEvent =
  // Execution lifecycle
  | ExecutionStartEvent
  | ExecutionEndEvent
  | ExecutionEvent
  // Tick lifecycle
  | TickStartEvent
  | TickEndEvent
  | TickEvent
  // Tool execution
  | ToolResultEvent
  | ToolConfirmationRequiredEvent
  | ToolConfirmationResultEvent
  // Errors
  | EngineErrorEvent;

// ============================================================================
// Combined Event Type
// ============================================================================

/**
 * EngineStreamEvent - Combined union of StreamEvent and EngineEvent.
 *
 * This is what engine.stream() yields - both model output events
 * and engine orchestration events.
 */
export type EngineStreamEvent = StreamEvent | EngineEvent;

// ============================================================================
// Event Type Guards
// ============================================================================

/**
 * Check if event is a StreamEvent (model output)
 */
export function isStreamEvent(event: EngineStreamEvent): event is StreamEvent {
  return [
    "content_start",
    "content_delta",
    "content_end",
    "content",
    "reasoning_start",
    "reasoning_delta",
    "reasoning_end",
    "reasoning",
    "message_start",
    "message_end",
    "message",
    "tool_call_start",
    "tool_call_delta",
    "tool_call_end",
    "tool_call",
    "error",
  ].includes(event.type);
}

/**
 * Check if event is an EngineEvent (orchestration)
 */
export function isEngineEvent(event: EngineStreamEvent): event is EngineEvent {
  return [
    "execution_start",
    "execution_end",
    "execution",
    "tick_start",
    "tick_end",
    "tick",
    "tool_result",
    "tool_confirmation_required",
    "tool_confirmation_result",
    "engine_error",
  ].includes(event.type);
}

/**
 * Check if event is a delta event (for streaming UI)
 */
export function isDeltaEvent(
  event: EngineStreamEvent,
): event is ContentDeltaEvent | ReasoningDeltaEvent | ToolCallDeltaEvent {
  return ["content_delta", "reasoning_delta", "tool_call_delta"].includes(event.type);
}

/**
 * Check if event is a final/complete event
 */
export function isFinalEvent(
  event: EngineStreamEvent,
): event is
  | ContentEvent
  | ReasoningEvent
  | MessageEvent
  | ToolCallEvent
  | TickEvent
  | ExecutionEvent {
  return ["content", "reasoning", "message", "tool_call", "tick", "execution"].includes(event.type);
}

// ============================================================================
// Legacy Types (Deprecated - for backward compatibility)
// ============================================================================

/**
 * @deprecated Use StreamEvent types instead
 */
export enum StreamChunkType {
  ERROR = "error",
  CONTENT_DELTA = "content_delta",
  CONTENT_START = "content_start",
  CONTENT_END = "content_end",
  CONTENT = "content",
  MESSAGE_START = "message_start",
  MESSAGE_END = "message_end",
  MESSAGE = "message",
  TOOL_INPUT_START = "tool_input_start",
  TOOL_INPUT_DELTA = "tool_input_delta",
  TOOL_INPUT_END = "tool_input_end",
  TOOL_CALL = "tool_call",
  TOOL_RESULT = "tool_result",
  REASONING_START = "reasoning_start",
  REASONING_DELTA = "reasoning_delta",
  REASONING_END = "reasoning_end",
  STEP_START = "step_start",
  STEP_END = "step_end",
}

/**
 * @deprecated Use StreamEvent instead. This interface is kept for backward compatibility.
 */
export interface StreamChunk {
  type: string;
  delta?: string;
  reasoning?: string;
  reasoningId?: string;
  id?: string;
  toolCallId?: string;
  toolName?: string;
  toolResult?: unknown;
  isToolError?: boolean;
  providerExecuted?: boolean;
  model?: string;
  stopReason?: StopReason;
  messageId?: string;
  message?: Message;
  blockType?: BlockType;
  mimeType?: string;
  block?: ContentBlock;
  index?: number;
  createdAt?: string;
  usage?: {
    inputTokens: number;
    outputTokens: number;
    reasoningTokens?: number;
    totalTokens: number;
    cachedInputTokens?: number;
  };
  toolCalls?: unknown[];
  stepRequest?: unknown;
  stepResponse?: unknown;
  stepWarnings?: unknown[];
  raw?: unknown;
  [key: string]: unknown;
}
