/**
 * Streaming Types
 *
 * Platform-independent types for streaming model responses and engine events.
 * Used by both backend (aidk-core) and frontend (aidk-client).
 *
 * ## Event Architecture
 *
 * - **StreamEvent**: Model output events (content, reasoning, messages, tool calls)
 * - **EngineEvent**: Orchestration events (execution lifecycle, ticks, tool results)
 * - **EngineStreamEvent**: Combined union of both (what engine.stream() yields)
 *
 * ## Event Pattern
 *
 * For streamable content, events follow the pattern:
 * ```
 * [thing]_start → [thing]_delta (0..n) → [thing]_end → [thing] (fully formed)
 * ```
 *
 * This allows consumers to choose granularity:
 * - Streaming UI: Listen for `*_delta` events
 * - Simple consumption: Listen for `content`, `reasoning`, `message`, `tool_call`
 */

import type { ContentBlock } from "./blocks";
import type { BlockType } from "./block-types";
import type { Message } from "./messages";
import type { TokenUsage } from "./models";
import type { ToolExecutor } from "./tools";

// ============================================================================
// Stop Reason
// ============================================================================

/**
 * Stop reason enumeration.
 * Defines why model generation stopped.
 *
 * Key distinction:
 * - NATURAL_COMPLETION: Model decided to stop (maps to provider's end_turn, stop, etc.)
 * - EXPLICIT_COMPLETION: Engine/runtime requested the stop (max ticks, abort, etc.)
 *
 * Usage by layer:
 * - StreamEvent (message_end): Model's stop reason (TOOL_USE, MAX_TOKENS, NATURAL_COMPLETION)
 * - EngineEvent (execution): May be EXPLICIT_COMPLETION if engine stopped early
 */
export enum StopReason {
  MAX_TOKENS = "max_tokens",
  STOP_SEQUENCE = "stop_sequence",
  CONTENT_FILTER = "content_filter",
  TOOL_USE = "tool_use",
  FUNCTION_CALL = "function_call",
  UNSPECIFIED = "unspecified",
  OTHER = "other",
  STOP = "stop",
  PAUSED = "paused",
  FORMAT_ERROR = "format_error",
  EMPTY_RESPONSE = "empty_response",
  NO_CONTENT = "no_content",
  EXPLICIT_COMPLETION = "explicit_completion",
  NATURAL_COMPLETION = "natural_completion",
  ERROR = "error",
}

// ============================================================================
// Base Event Structure
// ============================================================================

/**
 * Base fields shared by all stream events.
 */
export interface StreamEventBase {
  /** Normalized event ID (generated by entity-ids if provider doesn't provide one) */
  id: string;

  /** Tick number (default 1 for direct model calls without engine) */
  tick: number;

  /** ISO 8601 timestamp when event was created/emitted */
  timestamp: string;

  /** Original provider event/chunk for pass-through (debugging, provider-specific features) */
  raw?: unknown;
}

// ============================================================================
// StreamEvent (Model Output)
// ============================================================================

/**
 * Content block events (text, images, etc.)
 */
export type ContentStartEvent = {
  type: "content_start";
  blockType: BlockType;
  blockIndex: number;
} & StreamEventBase;

export type ContentDeltaEvent = {
  type: "content_delta";
  blockType: BlockType;
  blockIndex: number;
  delta: string;
} & StreamEventBase;

export type ContentEndEvent = {
  type: "content_end";
  blockType: BlockType;
  blockIndex: number;
} & StreamEventBase;

export type ContentEvent = {
  type: "content";
  blockIndex: number;
  content: ContentBlock;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Reasoning/thinking events (separate for easy filtering)
 */
export type ReasoningStartEvent = {
  type: "reasoning_start";
  blockIndex: number;
} & StreamEventBase;

export type ReasoningDeltaEvent = {
  type: "reasoning_delta";
  blockIndex: number;
  delta: string;
} & StreamEventBase;

export type ReasoningEndEvent = {
  type: "reasoning_end";
  blockIndex: number;
} & StreamEventBase;

export type ReasoningEvent = {
  type: "reasoning";
  blockIndex: number;
  reasoning: string;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Message lifecycle events
 */
export type MessageStartEvent = {
  type: "message_start";
  role: "assistant";
  model?: string;
} & StreamEventBase;

export type MessageEndEvent = {
  type: "message_end";
  stopReason: StopReason;
  usage?: TokenUsage;
} & StreamEventBase;

export type MessageEvent = {
  type: "message";
  message: Message;
  stopReason: StopReason;
  usage?: TokenUsage;
  model?: string;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Tool call events (model requesting tool execution)
 */
export type ToolCallStartEvent = {
  type: "tool_call_start";
  callId: string;
  name: string;
  blockIndex: number;
} & StreamEventBase;

export type ToolCallDeltaEvent = {
  type: "tool_call_delta";
  callId: string;
  blockIndex: number;
  delta: string;
} & StreamEventBase;

export type ToolCallEndEvent = {
  type: "tool_call_end";
  callId: string;
  blockIndex: number;
} & StreamEventBase;

export type ToolCallEvent = {
  type: "tool_call";
  callId: string;
  blockIndex: number;
  name: string;
  input: Record<string, unknown>;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Error event
 */
export type StreamErrorEvent = {
  type: "error";
  error: {
    message: string;
    code?: string;
  };
} & StreamEventBase;

/**
 * StreamEvent - All model output events.
 *
 * Discriminated union of all events that come from model streaming.
 */
export type StreamEvent =
  // Content blocks
  | ContentStartEvent
  | ContentDeltaEvent
  | ContentEndEvent
  | ContentEvent
  // Reasoning/thinking
  | ReasoningStartEvent
  | ReasoningDeltaEvent
  | ReasoningEndEvent
  | ReasoningEvent
  // Message lifecycle
  | MessageStartEvent
  | MessageEndEvent
  | MessageEvent
  // Tool calls
  | ToolCallStartEvent
  | ToolCallDeltaEvent
  | ToolCallEndEvent
  | ToolCallEvent
  // Errors
  | StreamErrorEvent;

// ============================================================================
// EngineEvent (Orchestration)
// ============================================================================

/**
 * Execution lifecycle events
 *
 * Note: threadId and other app-specific identifiers are in metadata.
 * sessionId is kept top-level as it's universal for client connections.
 */
export type ExecutionStartEvent = {
  type: "execution_start";
  executionId: string;
  sessionId?: string;
  parentExecutionId?: string;
  rootExecutionId?: string;
  componentName?: string;
  /** User-provided metadata (includes threadId, userId, etc.) */
  metadata?: Record<string, unknown>;
} & StreamEventBase;

export type ExecutionEndEvent = {
  type: "execution_end";
  executionId: string;
  sessionId?: string;
  parentExecutionId?: string;
  rootExecutionId?: string;
  output: unknown;
  /** User-provided metadata (includes threadId, userId, etc.) */
  metadata?: Record<string, unknown>;
} & StreamEventBase;

export type ExecutionEvent = {
  type: "execution";
  executionId: string;
  sessionId?: string;
  parentExecutionId?: string;
  rootExecutionId?: string;
  output: unknown;
  usage: TokenUsage;
  stopReason: StopReason;
  /** User-provided metadata (includes threadId, userId, etc.) */
  metadata?: Record<string, unknown>;
  ticks: number;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Tick lifecycle events
 */
export type TickStartEvent = {
  type: "tick_start";
  tick: number;
} & StreamEventBase;

export type TickEndEvent = {
  type: "tick_end";
  tick: number;
  usage?: TokenUsage;
  /** New timeline entries added during this tick (for persistence) */
  response?: {
    newTimelineEntries?: unknown[];
  };
} & StreamEventBase;

export type TickEvent = {
  type: "tick";
  tick: number;
  usage: TokenUsage;
  stopReason: StopReason;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Tool result event (unified - executedBy indicates source)
 */
export type ToolResultEvent = {
  type: "tool_result";
  callId: string;
  name: string;
  result: unknown;
  isError?: boolean;
  executedBy: ToolExecutor;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Tool confirmation events (for requiresConfirmation tools)
 */
export type ToolConfirmationRequiredEvent = {
  type: "tool_confirmation_required";
  callId: string;
  name: string;
  input: Record<string, unknown>;
  message: string;
} & StreamEventBase;

export type ToolConfirmationResultEvent = {
  type: "tool_confirmation_result";
  callId: string;
  confirmed: boolean;
  always?: boolean;
} & StreamEventBase;

/**
 * Engine error event
 */
export type EngineErrorEvent = {
  type: "engine_error";
  error: {
    message: string;
    code?: string;
  };
} & StreamEventBase;

/**
 * Fork lifecycle events
 *
 * Fork creates parallel execution branches that race or vote.
 * Each branch runs as a separate execution - subscribe to those
 * executions directly if you need branch-level observability.
 */
export type ForkStartEvent = {
  type: "fork_start";
  /** Unique identifier for this fork operation */
  forkId: string;
  /** Parent execution that initiated the fork */
  parentExecutionId: string;
  /** Strategy for handling branch results */
  strategy: "race" | "vote" | "all";
  /** Identifiers for each branch (variant names or indices) */
  branches: string[];
  /** Number of parallel branches */
  branchCount: number;
  /** Input passed to the fork (shared across branches or per-branch) */
  input?: unknown;
} & StreamEventBase;

export type ForkEndEvent = {
  type: "fork_end";
  /** Unique identifier for this fork operation */
  forkId: string;
  /** Parent execution that initiated the fork */
  parentExecutionId: string;
  /** The winning/selected branch (for race/vote strategies) */
  selectedBranch?: string;
  /** Aggregated results from all branches */
  results: Record<string, unknown>;
  /** Token usage aggregated across all branches */
  usage?: TokenUsage;
} & StreamEventBase;

/**
 * Spawn lifecycle events
 *
 * Spawn creates a child execution that runs independently.
 * Unlike Fork, Spawn doesn't race - it's for delegation.
 */
export type SpawnStartEvent = {
  type: "spawn_start";
  /** Unique identifier for this spawn operation */
  spawnId: string;
  /** Parent execution that initiated the spawn */
  parentExecutionId: string;
  /** Child execution ID */
  childExecutionId: string;
  /** Name of the spawned component/agent */
  componentName?: string;
  /** Optional label for this spawn */
  label?: string;
  /** Input passed to the spawned execution */
  input?: unknown;
} & StreamEventBase;

export type SpawnEndEvent = {
  type: "spawn_end";
  /** Unique identifier for this spawn operation */
  spawnId: string;
  /** Parent execution that initiated the spawn */
  parentExecutionId: string;
  /** Child execution ID */
  childExecutionId: string;
  /** Output from the spawned execution */
  output: unknown;
  /** Whether the spawn errored */
  isError?: boolean;
  /** Token usage from the spawned execution */
  usage?: TokenUsage;
} & StreamEventBase;

/**
 * EngineEvent - All orchestration events.
 *
 * Discriminated union of all events from engine orchestration.
 */
export type EngineEvent =
  // Execution lifecycle
  | ExecutionStartEvent
  | ExecutionEndEvent
  | ExecutionEvent
  // Tick lifecycle
  | TickStartEvent
  | TickEndEvent
  | TickEvent
  // Tool execution
  | ToolResultEvent
  | ToolConfirmationRequiredEvent
  | ToolConfirmationResultEvent
  // Fork/Spawn orchestration
  | ForkStartEvent
  | ForkEndEvent
  | SpawnStartEvent
  | SpawnEndEvent
  // Errors
  | EngineErrorEvent;

// ============================================================================
// Combined Event Type
// ============================================================================

/**
 * EngineStreamEvent - Combined union of StreamEvent and EngineEvent.
 *
 * This is what engine.stream() yields - both model output events
 * and engine orchestration events.
 */
export type EngineStreamEvent = StreamEvent | EngineEvent;

// ============================================================================
// Event Type Guards
// ============================================================================

/**
 * Check if event is a StreamEvent (model output)
 */
export function isStreamEvent(event: EngineStreamEvent): event is StreamEvent {
  return [
    "content_start",
    "content_delta",
    "content_end",
    "content",
    "reasoning_start",
    "reasoning_delta",
    "reasoning_end",
    "reasoning",
    "message_start",
    "message_end",
    "message",
    "tool_call_start",
    "tool_call_delta",
    "tool_call_end",
    "tool_call",
    "error",
  ].includes(event.type);
}

/**
 * Check if event is an EngineEvent (orchestration)
 */
export function isEngineEvent(event: EngineStreamEvent): event is EngineEvent {
  return [
    "execution_start",
    "execution_end",
    "execution",
    "tick_start",
    "tick_end",
    "tick",
    "tool_result",
    "tool_confirmation_required",
    "tool_confirmation_result",
    "fork_start",
    "fork_end",
    "spawn_start",
    "spawn_end",
    "engine_error",
  ].includes(event.type);
}

/**
 * Check if event is a Fork event
 */
export function isForkEvent(event: EngineStreamEvent): event is ForkStartEvent | ForkEndEvent {
  return ["fork_start", "fork_end"].includes(event.type);
}

/**
 * Check if event is a Spawn event
 */
export function isSpawnEvent(event: EngineStreamEvent): event is SpawnStartEvent | SpawnEndEvent {
  return ["spawn_start", "spawn_end"].includes(event.type);
}

/**
 * Check if event is a delta event (for streaming UI)
 */
export function isDeltaEvent(
  event: EngineStreamEvent,
): event is ContentDeltaEvent | ReasoningDeltaEvent | ToolCallDeltaEvent {
  return ["content_delta", "reasoning_delta", "tool_call_delta"].includes(event.type);
}

/**
 * Check if event is a final/complete event
 */
export function isFinalEvent(
  event: EngineStreamEvent,
): event is
  | ContentEvent
  | ReasoningEvent
  | MessageEvent
  | ToolCallEvent
  | TickEvent
  | ExecutionEvent {
  return ["content", "reasoning", "message", "tool_call", "tick", "execution"].includes(event.type);
}

// ============================================================================
// Legacy Types (Deprecated - for backward compatibility)
// ============================================================================

/**
 * @deprecated Use StreamEvent types instead.
 * StreamChunkType was replaced by discriminated union types like ContentDeltaEvent, MessageEndEvent, etc.
 * The new StreamEvent union provides better type safety with proper discriminated unions.
 *
 * Migration guide:
 * - StreamChunkType.CONTENT_DELTA -> event.type === "content_delta" (ContentDeltaEvent)
 * - StreamChunkType.MESSAGE_END -> event.type === "message_end" (MessageEndEvent)
 * - StreamChunkType.TOOL_CALL -> event.type === "tool_call" (ToolCallEvent)
 * - etc.
 */
export enum StreamChunkType {
  ERROR = "error",
  CONTENT_DELTA = "content_delta",
  CONTENT_START = "content_start",
  CONTENT_END = "content_end",
  CONTENT = "content",
  MESSAGE_START = "message_start",
  MESSAGE_END = "message_end",
  MESSAGE = "message",
  TOOL_INPUT_START = "tool_input_start",
  TOOL_INPUT_DELTA = "tool_input_delta",
  TOOL_INPUT_END = "tool_input_end",
  TOOL_CALL = "tool_call",
  TOOL_RESULT = "tool_result",
  REASONING_START = "reasoning_start",
  REASONING_DELTA = "reasoning_delta",
  REASONING_END = "reasoning_end",
  STEP_START = "step_start",
  STEP_END = "step_end",
}

/**
 * @deprecated Use StreamEvent instead. This interface is kept for backward compatibility.
 *
 * StreamChunk was a flat, loosely-typed object for streaming chunks.
 * StreamEvent is a discriminated union with strict types for each event kind.
 *
 * Migration example:
 * ```typescript
 * // Old StreamChunk usage:
 * if (chunk.type === "content_delta") {
 *   console.log(chunk.delta); // Might be undefined, no type narrowing
 * }
 *
 * // New StreamEvent usage:
 * if (event.type === "content_delta") {
 *   console.log(event.delta); // Guaranteed to exist, type-safe
 * }
 * ```
 *
 * Key differences:
 * - StreamEvent.id is required (auto-generated if needed)
 * - StreamEvent.tick is required (default: 1)
 * - StreamEvent.timestamp is required (ISO 8601)
 * - Each event type has specific required fields
 */
export interface StreamChunk {
  type: string;
  delta?: string;
  reasoning?: string;
  reasoningId?: string;
  id?: string;
  toolCallId?: string;
  toolName?: string;
  toolResult?: unknown;
  isToolError?: boolean;
  providerExecuted?: boolean;
  model?: string;
  stopReason?: StopReason;
  messageId?: string;
  message?: Message;
  blockType?: BlockType;
  mimeType?: string;
  block?: ContentBlock;
  index?: number;
  createdAt?: string;
  usage?: {
    inputTokens: number;
    outputTokens: number;
    reasoningTokens?: number;
    totalTokens: number;
    cachedInputTokens?: number;
  };
  toolCalls?: unknown[];
  stepRequest?: unknown;
  stepResponse?: unknown;
  stepWarnings?: unknown[];
  raw?: unknown;
  [key: string]: unknown;
}
